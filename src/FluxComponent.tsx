import React from 'react';
import _ from 'underscore';
import uniqid from 'uniqid'

// A shared entry is a pair of a secret string and its corresponding value:
interface SharedKey<T> {
    secret: string,
    value: T
}

/*
   The shared store maps an incoming interface from 
      <string, T> 
   to 
      <string, <SharedKey<T>>
   which corresponds to 
      <string, <stringX, T>>
   -> stringX will be the autogenerated shared secret, which has same purpose of "action.type" in a standard React-Redux implementation
*/
type SharedStore<SS> = {
    [K in keyof SS]: SharedKey<SS[K]>
}

// Subset of SharedStore
type SharedSubset = Record<string, SharedKey<unknown>>

// Component's state: children will need to extend this State interface.
export interface State {
    shared: SharedSubset
}

//https://github.com/microsoft/TypeScript/issues/30355#issuecomment-671095933
export default <SS extends {}>(initSharedState: SS) =>
    class FluxComponent<P extends {} = {}, S extends State = State> extends React.Component<P, S> {
        public static readonly shared: SharedStore<SS> = FluxComponent.makeStore(initSharedState)

        // Triggers component re-render on update.
        // Use this when the binded value is needed in this component's rendering.
        protected hardBind = <T extends unknown>(svPair: SharedKey<T>) => {
            const { secret, value } = svPair

            if (this.sharedKeys.length === 0) {
                FluxComponent.children.push(this)
            }

            this.sharedKeys.push(secret)

            if (this.mounted) super.setState({  // (*)
                ...this.state,
                shared: {
                    ...this.state.shared,
                    [secret]: value
                }
            })

            return this.softBind<T>(svPair)
        }

        // Doesn't trigger component re-render when updated.
        // Use this to update states shared among external components.
        // protected softBind = <T extends unknown>([secret,]: SharedKey<T>) => {
        protected softBind = <T extends unknown>({ secret }: SharedKey<T>) => {
            let [key] = Object.entries(FluxComponent.__sharedState).find(([, { secret }]) => {
                return secret === secret
            })!
            let self = this

            return {
                get value() {
                    return FluxComponent.__sharedState[key].value as T
                },
                set value(value: T) {
                    self.__setSharedState({
                        ...FluxComponent.__sharedState,
                        [key]: { secret, value }
                    } as SharedStore<SS>)
                }
            }
        }

        // #region Internal Only

        constructor(props: P) {
            super(props)
            this.state = {
                ...this.state,
                shared: {}
            }
            this.sharedKeys = []
        }

        // (*)
        // Checking mounted state is currently considered as an anti-pattern: it should be known whether 
        // the component has been unmounted or not. 
        // However, in this case the setState this might actually get called *before* the component 
        // was mounted - I'll stick with this while looking for a better solution.
        private mounted: boolean = false

        // Without any noticeable drawback, I preferred this deprecated method over 
        // componentDidMount = () => {
        // to avoid a mandatory super.componentDidMount() in children's implementations.
        UNSAFE_componentWillMount = () => {
            this.mounted = true
        }

        private static __sharedState: SharedSubset

        // Had to declare this protected instead of private, to call it 
        // from the anonymous class returning from makeComponent.
        protected static makeStore(initialSharedState: SS) {
            let initializedState: SharedSubset = {}

            for (let [key, value] of Object.entries(initialSharedState)) {
                const secret = uniqid()
                initializedState[key] = { secret, value }
            }

            FluxComponent.__sharedState = initializedState as SharedStore<SS>

            let _shared = {}

            //FluxComponent.shared[key] dynamically refers to FluxComponent.__sharedState[key]
            for (let key of Object.keys(FluxComponent.__sharedState)) {
                Object.defineProperty(_shared, key, {
                    get: function () {
                        return FluxComponent.__sharedState[key]
                    }
                })
            }

            return _shared as SharedStore<SS>
        }

        // newSharedState type must match SharedStore<SS> and therefore method can't be static
        private async __setSharedState(newSharedState: SharedStore<SS>) {
            FluxComponent.__sharedState = Object.freeze(newSharedState)
            await this.__dispatchToChildren()
        }

        private static children: FluxComponent[] = []

        // Dispatching to each children its binded keys values only
        private sharedKeys: string[]

        private async __dispatchToChildren() {
            let bindings: Promise<SharedSubset>[] = []
            FluxComponent.children.forEach(child => {
                bindings.push(child.__bindKeys())
            });

            return Promise.all(bindings)
        }

        private __bindKeys = () => {
            let shared: SharedSubset = Object.assign({}, FluxComponent.__sharedState)

            for (let [key, { secret }] of Object.entries(FluxComponent.__sharedState)) {
                if (!this.sharedKeys.includes(secret)) delete shared[key]
            }

            return new Promise<SharedSubset>((resolve) => {
                if (_.isEqual(shared, this.state.shared)) resolve(shared)
                else super.setState({
                    ...this.state, shared
                }, () => {
                    resolve(shared)
                })
            })
        }

        //#endregion
    }
