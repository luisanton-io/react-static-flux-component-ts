import React from 'react';
import _ from 'underscore';
import uniqid from 'uniqid'

// A shared entry is a pair of a secret string and its corresponding value:
interface SharedKey<T> {
    secret: string,
    value: T
}

/*
   The shared store maps an incoming interface from 
      <string, T> 
   to 
      <string, <SharedKey<T>>
   which corresponds to 
      <string, {
          secret: string,
          value: T
      }>
   -> the secret string will be autogenerated, which has same purpose of "action.type" in a standard React-Redux implementation
*/
type SharedStore<SS> = {
    [K in keyof SS]: SharedKey<SS[K]>
}

// Subset of SharedStore
type SharedSubset = Record<string, unknown>
type SharedSubsetEntry = [string,SharedKey<unknown>]

// Component's state: children will need to extend this State interface.
export interface State {
    shared: SharedSubset
}

//https://github.com/microsoft/TypeScript/issues/30355#issuecomment-671095933
export default <SS extends {}>(initSharedState: SS) =>
    class FluxComponent<P extends {} = {}, S extends State = State> extends React.Component<P, S> {

        //Exposed and write-protected mirror of private __shared property
        public static readonly shared: SharedStore<SS> = FluxComponent.makeStore(initSharedState)

        // Triggers component re-render on update.
        // Use this when the binded value is needed in this component's rendering.
        protected hardBind = <T extends unknown>(sharedKey: SharedKey<T>) => {
            const { secret, value } = Object.assign({}, sharedKey)

            if (this.sharedKeys.length === 0) {
                FluxComponent.children.push(this)
            }

            this.sharedKeys.push(secret)

            if (this.mounted) super.setState({  // (*)
                ...this.state,
                shared: {
                    ...this.state.shared,
                    [secret]: value
                }
            })
            
            return this.softBind<T>(sharedKey)
        }
        
        // Doesn't trigger component re-render when updated.
        // Use this to update states shared among external components.
            protected softBind = <T extends unknown>(sharedKey: SharedKey<T>) => {
                
                let { secret } = Object.assign({}, sharedKey)
                let [key] = (Object.entries(FluxComponent.__shared) as SharedSubsetEntry[]).find( ([,sharedKey]) => {  
                    return secret === sharedKey.secret
                })!
                
                return {
                    get value() {
                        return FluxComponent.__shared[key].value as T
                    },
                    set value(value: T) {
                     
                    FluxComponent.__shared = Object.freeze({
                        ...FluxComponent.__shared,
                        [key]: { secret, value }
                    } as SharedStore<SS>)

                    FluxComponent.__dispatchToChildren<T>()
                }
            }
        }

        // #region Internal Only

        constructor(props: P) {
            super(props)
            this.state = {
                ...this.state,
                shared: {}
            }
            this.sharedKeys = []
        }

        // (*)
        // Checking mounted state is currently considered as an anti-pattern: it should be known whether 
        // the component has been unmounted or not. 
        // However, in this case the setState this might actually get called *before* the component 
        // was mounted - I'll stick with this while looking for a better solution.
        private mounted: boolean = false

        // Without any noticeable drawback, I preferred this deprecated method over 
        // componentDidMount = () => {
        // to avoid a mandatory super.componentDidMount() in children's implementations.
        UNSAFE_componentWillMount = () => {
            this.mounted = true
        }

        private static __shared: SharedStore<SS>

        // Had to declare this protected instead of private, to call it 
        // from the anonymous class returning from makeComponent.
        protected static makeStore(initialSharedState: SS) {
            let initializedState = {}

            for (let [key, value] of Object.entries(initialSharedState)) {
                const secret = uniqid()
                initializedState[key] = { secret, value }
            }

            FluxComponent.__shared = initializedState as SharedStore<SS>

            let shared = {}

            //FluxComponent.shared[key] dynamically refers to FluxComponent.__shared[key]
            for (let key of Object.keys(FluxComponent.__shared)) {
                Object.defineProperty(shared, key, {
                    get: function () {
                        return FluxComponent.__shared[key]
                    }
                })
            }

            return shared as SharedStore<SS>
        }

        private static children: FluxComponent[] = []

        // Dispatching to each children its binded keys values only
        private sharedKeys: string[]

        private static __dispatchToChildren<T>() {
            for (let child of this.children) {
                let shared: SharedSubset = {}

                for (let {secret, value} of Object.values(FluxComponent.__shared) as SharedKey<T>[]) {
                    if (child.sharedKeys.includes(secret)) {
                        shared[secret] = value
                    }
                }

                if (!_.isEqual(shared, child.state.shared)) {
                    child.setState({...child.state, shared})
                }
            }
        }

        //#endregion
    }
